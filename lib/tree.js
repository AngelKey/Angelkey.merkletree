// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  var Base, Config, Lock, SortedMap, chain_err, format_hex, hex_cmp, hex_len, iced, list_to_tab, log_16, make_esc, map, node_types, shallow_copy, tab_to_list, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  Lock = require('iced-utils').lock.Lock;

  _ref = require('iced-error'), chain_err = _ref.chain_err, make_esc = _ref.make_esc;

  exports.node_types = node_types = {
    NONE: 0,
    INODE: 1,
    LEAF: 2
  };

  log_16 = function(y) {
    var ret;
    ret = 0;
    while (y > 1) {
      y = y >> 4;
      ret++;
    }
    return ret;
  };

  shallow_copy = function(obj) {
    var k, ret, tab, v, _ref1;
    tab = {};
    ret = {
      type: obj.type,
      tab: tab
    };
    _ref1 = obj.tab;
    for (k in _ref1) {
      v = _ref1[k];
      tab[k] = v;
    }
    return ret;
  };

  format_hex = function(i, len) {
    var buf;
    buf = new Buffer(4);
    buf.writeUInt32BE(i, 0);
    return buf.toString('hex').slice(8 - len);
  };

  list_to_tab = function(list) {
    var pair, tab, _i, _len;
    tab = {};
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      pair = list[_i];
      tab[pair[0]] = pair[1];
    }
    return tab;
  };

  tab_to_list = function(tab) {
    var k, v, _results;
    _results = [];
    for (k in tab) {
      v = tab[k];
      _results.push([k, v]);
    }
    return _results;
  };

  hex_len = function(a) {
    var c, ret, _i, _len;
    ret = a.length;
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      c = a[_i];
      if (c === '0') {
        ret--;
      } else {
        break;
      }
    }
    return ret;
  };

  map = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };

  hex_cmp = function(a, b) {
    var a_len, b_len, c, d, i, ret, tmp;
    a_len = hex_len(a);
    b_len = hex_len(b);
    ret = (function() {
      var _i, _len;
      if (a_len > b_len) {
        return 1;
      } else if (a_len < b_len) {
        return -1;
      } else {
        tmp = 0;
        for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
          c = a[i];
          d = b[i];
          if (map[c] > map[d]) {
            tmp = 1;
          } else if (map[c] < map[d]) {
            tmp = -1;
          }
          if (tmp !== 0) {
            break;
          }
        }
        return tmp;
      }
    })();
    return ret;
  };

  exports.SortedMap = SortedMap = (function() {
    function SortedMap(_arg) {
      var i, j, k, key, list, node, obj, sorted, sorted_list, v, val, _i, _ref1;
      node = _arg.node, obj = _arg.obj, list = _arg.list, sorted_list = _arg.sorted_list, key = _arg.key, val = _arg.val;
      if (node != null) {
        obj = node.tab;
        this._type = node.type;
      }
      if (obj != null) {
        list = (function() {
          var _results;
          _results = [];
          for (k in obj) {
            v = obj[k];
            _results.push([k, v]);
          }
          return _results;
        })();
      } else if (sorted_list != null) {
        this._list = sorted_list;
      }
      if ((key != null) && (val != null)) {
        this._list = [[key, val]];
      }
      if ((list != null) && (this._list == null)) {
        sorted = true;
        for (i = _i = 0, _ref1 = list.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          j = i + 1;
          if ((j < list.length) && (hex_cmp(list[i][0], list[j][0])) > 0) {
            sorted = false;
            break;
          }
        }
        if (!sorted) {
          list.sort(function(a, b) {
            return hex_cmp(a[0], b[0]);
          });
        }
        this._list = l;
      }
      if (this._list == null) {
        this._list = [];
      }
    }

    SortedMap.prototype.slice = function(a, b) {
      return new SortedMap({
        sorted_list: this._list.slice(a, b)
      });
    };

    SortedMap.prototype.len = function() {
      return this._list.length;
    };

    SortedMap.prototype.at = function(i) {
      return this._list[i];
    };

    SortedMap.prototype.to_hash = function(_arg) {
      var JS, hash, hasher, k, obj, parts, tab, type, v, _i, _len, _ref1, _ref2;
      hasher = _arg.hasher, type = _arg.type;
      JS = JSON.stringify;
      type || (type = this._type);
      parts = [];
      tab = {};
      _ref1 = this._list;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], k = _ref2[0], v = _ref2[1];
        parts.push([JS(k), JS(v)].join(":"));
        tab[k] = v;
      }
      tab = "{" + parts.join(",") + "}";
      obj_s("{\"tab\":" + tab + ",\"type\":" + type + "}");
      obj = {
        tab: tab,
        type: type
      };
      hash = hasher(obj_s);
      return {
        hash: hash,
        obj: obj,
        obj_s: obj_s
      };
    };

    SortedMap.prototype.binary_search = function(_arg) {
      var beg, c, end, eq, key, mid, ret;
      key = _arg.key;
      beg = 0;
      end = this._list.length - 1;
      while (beg < end) {
        mid = (end - beg) >> 1;
        c = hex_cmp(key, this._list[mid][0]);
        if (c > 0) {
          beg = mid + 1;
        } else if (c < 0) {
          end = mid;
        }
      }
      c = hex_cmp(key, this._list[beg][0]);
      eq = 0;
      ret = c > 0 ? beg + 1 : c === 0 ? (eq = 1, beg) : beg;
      return [beg, eq];
    };

    SortedMap.prototype.replace = function(_arg) {
      var eq, index, key, val, _ref1;
      key = _arg.key, val = _arg.val;
      _ref1 = this.binary_search({
        key: key
      }), index = _ref1[0], eq = _ref1[1];
      this._list = this._list.slice(0, index).concat([[key, val]]).concat(this._list.slice(index + eq));
      return this;
    };

    return SortedMap;

  })();

  exports.Config = Config = (function() {
    function Config(_arg) {
      this.M = _arg.M, this.N = _arg.N;
      this.C = Math.ceil(this.M / 4);
    }

    return Config;

  })();

  exports.Base = Base = (function() {
    function Base(_arg) {
      this.config = _arg.config;
      this._lock = new Lock;
      this.hasher = this.hash_fn.bind(this);
    }

    Base.prototype.unimplemented = function() {
      return new Error("unimplemented");
    };

    Base.prototype.hash_fn = function(s) {
      return this.unimplemented();
    };

    Base.prototype.store_node = function(_arg, cb) {
      var key, obj, obj_s;
      key = _arg.key, obj = _arg.obj, obj_s = _arg.obj_s;
      return this.unimplemented();
    };

    Base.prototype.commit_root = function(_arg, cb) {
      var key;
      key = _arg.key;
      return this.unimplemented();
    };

    Base.prototype.lookup_node = function(_arg, cb) {
      var key;
      key = _arg.key;
      return this.unimplemented();
    };

    Base.prototype.lookup_root = function(cb) {
      return this.unimplemented();
    };

    Base.prototype.obj_to_key = function(o) {
      return o[0];
    };

    Base.prototype.prefix_at_level = function(_arg) {
      var key, level, obj;
      level = _arg.level, key = _arg.key, obj = _arg.obj;
      key || (key = this.obj_to_key(obj));
      return key.slice(level * this.C, (level + 1) * this.C);
    };

    Base.prototype.prefix_through_level = function(_arg) {
      var key, level, obj;
      level = _arg.level, key = _arg.key, obj = _arg.obj;
      key || (key = this.obj_to_key(obj));
      return key.slice(0, (level + 1) * this.C);
    };

    Base.prototype.unlock = function(cb) {
      this._lock.release();
      return cb(null);
    };

    Base.prototype.upsert = function(_arg, cb) {
      var curr, esc, h, key, last, level, nxt, obj, obj_s, p, path, root, sm, sorted_map, v2, val, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key = _arg.key, val = _arg.val;
      cb = chain_err(cb, this.unlock.bind(this));
      esc = make_esc(cb, "full_build");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
            funcname: "Base.upsert"
          });
          _this._lock.acquire(__iced_deferrals.defer({
            lineno: 230
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
              funcname: "Base.upsert"
            });
            _this.lookup_root(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return root = arguments[0];
                };
              })(),
              lineno: 233
            }));
            __iced_deferrals._fulfill();
          })(function() {
            curr = null;
            (function(__iced_k) {
              if (typeof root !== "undefined" && root !== null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
                    funcname: "Base.upsert"
                  });
                  _this.lookup_node({
                    key: root
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return curr = arguments[0];
                      };
                    })(),
                    lineno: 236
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              last = null;
              path = [];
              (function(__iced_k) {
                var _results, _while;
                _results = [];
                _while = function(__iced_k) {
                  var _break, _continue, _next;
                  _break = function() {
                    return __iced_k(_results);
                  };
                  _continue = function() {
                    return iced.trampoline(function() {
                      return _while(__iced_k);
                    });
                  };
                  _next = function(__iced_next_arg) {
                    _results.push(__iced_next_arg);
                    return _continue();
                  };
                  if (curr == null) {
                    return _break();
                  } else {
                    p = _this.prefix_through_level({
                      key: key,
                      level: path.length
                    });
                    path.push([p, curr]);
                    last = curr;
                    (function(__iced_k) {
                      if ((nxt = curr.tab[p]) != null) {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
                            funcname: "Base.upsert"
                          });
                          _this.lookup_node({
                            key: nxt
                          }, esc(__iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return curr = arguments[0];
                              };
                            })(),
                            lineno: 247
                          })));
                          __iced_deferrals._fulfill();
                        })(__iced_k);
                      } else {
                        return __iced_k(curr = null);
                      }
                    })(_next);
                  }
                };
                _while(__iced_k);
              })(function() {
                var _ref1;
                _ref1 = last == null ? [
                  new SortedMap({
                    key: key,
                    val: val
                  }), path.length
                ] : last.type === node_types.INODE ? [
                  new SortedMap({
                    key: key,
                    val: val
                  }), path.length + 1
                ] : !((v2 = last.tab[key]) != null) || !(deq(val, v2)) ? [
                  (new SortedMap({
                    obj: last.tab
                  })).replace({
                    key: key,
                    val: val
                  }), path.length
                ] : [null, 0], sorted_map = _ref1[0], level = _ref1[1];
                (function(__iced_k) {
                  if (typeof store_list !== "undefined" && store_list !== null) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
                        funcname: "Base.upsert"
                      });
                      _this.hash_tree_r({
                        level: level,
                        sorted_map: sorted_map
                      }, esc(__iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return h = arguments[0];
                          };
                        })(),
                        lineno: 263
                      })));
                      __iced_deferrals._fulfill();
                    })(function() {
                      path.reverse();
                      (function(__iced_k) {
                        var _i, _len, _ref2, _results, _while;
                        _ref2 = path;
                        _len = _ref2.length;
                        _i = 0;
                        _results = [];
                        _while = function(__iced_k) {
                          var _break, _continue, _next, _ref3, _ref4;
                          _break = function() {
                            return __iced_k(_results);
                          };
                          _continue = function() {
                            return iced.trampoline(function() {
                              ++_i;
                              return _while(__iced_k);
                            });
                          };
                          _next = function(__iced_next_arg) {
                            _results.push(__iced_next_arg);
                            return _continue();
                          };
                          if (!(_i < _len)) {
                            return _break();
                          } else {
                            _ref3 = _ref2[_i], p = _ref3[0], curr = _ref3[1];
                            if (curr.type === node_types.INODE) {
                              sm = (new SortedMap({
                                node: curr
                              })).replace({
                                key: p,
                                val: h
                              });
                              _ref4 = sm.to_hash({
                                hasher: _this.hasher
                              }), key = _ref4.key, obj = _ref4.obj, obj_s = _ref4.obj_s;
                              h = key;
                              (function(__iced_k) {
                                __iced_deferrals = new iced.Deferrals(__iced_k, {
                                  parent: ___iced_passed_deferral,
                                  filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
                                  funcname: "Base.upsert"
                                });
                                _this.store_node({
                                  key: key,
                                  obj: obj,
                                  obj_s: obj_s
                                }, esc(__iced_deferrals.defer({
                                  lineno: 271
                                })));
                                __iced_deferrals._fulfill();
                              })(_next);
                            } else {
                              return _continue();
                            }
                          }
                        };
                        _while(__iced_k);
                      })(function() {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
                            funcname: "Base.upsert"
                          });
                          _this.commit_root(h, esc(__iced_deferrals.defer({
                            lineno: 274
                          })));
                          __iced_deferrals._fulfill();
                        })(__iced_k);
                      });
                    });
                  } else {
                    return __iced_k();
                  }
                })(function() {
                  return cb(null);
                });
              });
            });
          });
        };
      })(this));
    };

    Base.prototype.hash_tree_r = function(_arg, cb) {
      var C, M, end, err, h, i, j, key, level, new_sorted_map, obj, obj_s, prefix, sorted_map, start, sublist, ___iced_passed_deferral, __iced_deferrals, __iced_k, _begin, _end, _positive;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      level = _arg.level, sorted_map = _arg.sorted_map;
      err = null;
      key = null;
      (function(_this) {
        return (function(__iced_k) {
          var _ref1;
          if (list.length < _this["const"].N) {
            _ref1 = sorted_map.to_hash({
              hasher: _this.hasher,
              type: node_types.LEAF
            }), key = _ref1.key, obj = _ref1.obj, obj_s = _ref1.obj_s;
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
                funcname: "Base.hash_tree_r"
              });
              _this.store_node({
                key: key,
                obj: obj,
                obj_s: obj_s
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 286
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            M = 1 << _this["const"].M;
            C = _this["const"].C;
            j = 0;
            new_sorted_map = new SortedMap({});
            (function(__iced_k) {
              var _i, _results, _while;
              i = 0;
              _begin = 0;
              _end = M;
              _positive = _end > _begin;
              _results = [];
              _while = function(__iced_k) {
                var _break, _continue, _next;
                _break = function() {
                  return __iced_k(_results);
                };
                _continue = function() {
                  return iced.trampoline(function() {
                    if (_positive) {
                      i += 1;
                    } else {
                      i -= 1;
                    }
                    return _while(__iced_k);
                  });
                };
                _next = function(__iced_next_arg) {
                  _results.push(__iced_next_arg);
                  return _continue();
                };
                if (!!((_positive === true && i >= M) || (_positive === false && i <= M))) {
                  return _break();
                } else {

                  prefix = format_hex(i, C);
                  start = j;
                  while (j < sorted_map.len() && (_this.prefix_at_level({
                      level: level,
                      obj: sorted_map.at(j)
                    }) === prefix)) {
                    j++;
                  }
                  end = j;
                  (function(__iced_k) {
                    if (end > start) {
                      sublist = sorted_map.slice(start, end);
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
                          funcname: "Base.hash_tree_r"
                        });
                        _this.hash_tree_r({
                          level: level + 1,
                          sorted_map: sublist
                        }, __iced_deferrals.defer({
                          assign_fn: (function() {
                            return function() {
                              err = arguments[0];
                              return h = arguments[1];
                            };
                          })(),
                          lineno: 300
                        }));
                        __iced_deferrals._fulfill();
                      })(function() {
                        (function(__iced_k) {
                          if (err != null) {
                            (function(__iced_k) {
_break()
                            })(__iced_k);
                          } else {
                            return __iced_k();
                          }
                        })(function() {
                          prefix = _this.prefix_through_level({
                            level: level,
                            obj: sublist.at(0)
                          });
                          return __iced_k(new_sorted_map.push({
                            key: prefix,
                            val: h
                          }));
                        });
                      });
                    } else {
                      return __iced_k();
                    }
                  })(_next);
                }
              };
              _while(__iced_k);
            })(function() {
              (function(__iced_k) {
                var _ref2;
                if (err == null) {
                  _ref2 = new_sorted_map.to_hash({
                    hasher: _this.hasher,
                    type: node_types.INODE
                  }), key = _ref2.key, obj = _ref2.obj, obj_s = _ref2.obj_s;
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-merkle-tree/src/tree.iced",
                      funcname: "Base.hash_tree_r"
                    });
                    _this.store_node({
                      key: key,
                      obj: obj,
                      obj_s: obj_s
                    }, __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return err = arguments[0];
                        };
                      })(),
                      lineno: 306
                    }));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(__iced_k);
            });
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, key);
        };
      })(this));
    };

    return Base;

  })();

}).call(this);
